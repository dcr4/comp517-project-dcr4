
1. in the url class, we need to send the "Accept-Encoding" header to list compresion algorithms that we suppport and interpret the "Content-Encoding" header when received
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding

Compression: Add support for HTTP compression, in which the browser informs the server that compressed data is acceptable. Your browser must send the Accept-Encoding header with the value gzip. If the server supports compression, its response will have a Content-Encoding header with value gzip. The body is then compressed. Add support for this case. To decompress the data, you can use the decompress method in the gzip module. Calling makefile with the encoding argument will no longer work, because compressed data is not utf8-encoded. You can change the first argument "rb" to work with raw bytes instead of encoded text. Most web servers send compressed data in a Transfer-Encoding called chunked. You’ll need to add support for that, too, to access most web servers that support compressed data.There’s also a couple of Transfer-Encodings that compress the data. Those aren’t commonly used.

2. add support for a non-utf8 value for Content-Type

Alternate encodings: add support for a non-utf8 value for Content-Type. Test it on a real site such as google.com (which doesn’t use utf8).

3. add support for the file scheme which allows the browser to open local files

File URLs: Add support for the file scheme, which allows the browser to open local files. For example, file:///path/goes/here should refer to the file on your computer at location /path/goes/here. Also make it so that, if your browser is started without a URL being given, some specific file on your computer is opened. You can use that file for quick testing.

4. add support for data scheme

data: Yet another scheme is data, which allows inlining HTML content into the URL itself. Try navigating to data:text/html,Hello world! in a real browser to see what happens. Add support for this scheme to your browser. The data scheme is especially convenient for making tests without having to put them in separate files.

5. add support for lt and gt entities

Entities: Implement support for the less-than (&lt;) and greater-than (&gt;) entities. These should be printed as < and >, respectively. For example, if the HTML response was &lt;div&gt;, the show method of your browser should print <div>. Entities allow web pages to include these special characters without the browser interpreting them as tags.

6. add suppport for view source scheme

view-source: In addition to HTTP and HTTPS, there are other schemes, such as view-source; navigating in a real browser to view-source:http://browser.engineering/http.html shows the HTML source of this chapter rather than its rendered output. Add support for the view-source scheme. Your browser should print the entire HTML file as if it was text. Hint: To do so, you can utilize the entities from the previous exercise, and add an extra transform() method that adjusts the input to show() when in view-source mode, like this: show(transform(body))

7. add support for redirects

Redirects: Error codes in the 300 range request a redirect. When your browser encounters one, it should make a new request to the URL given in the Location header. Sometimes the Location header is a full URL, but sometimes it skips the host and scheme and just starts with a / (meaning the same host and scheme as the original request). The new URL might itself be a redirect, so make sure to handle that case. You don’t, however, want to get stuck in a redirect loop, so make sure limit how many redirects your browser can follow in a row. You can test this with the URL http://browser.engineering/redirect, which redirects back to this page.

8. cache https responses

Caching: Typically the same images, styles, and scripts are used on multiple pages; downloading them repeatedly is a waste. It’s generally valid to cache any HTTP response, as long as it was requested with GET and received a 200 response.Some other status codes like 301 and 404 can also be cached. Implement a cache in your browser and test it by requesting the same file multiple times. Servers control caches using the Cache-Control header. Add support for this header, specifically for no-store and max-age values. If the Cache-Control header contains any other value than these two, it’s best not to cache the response.